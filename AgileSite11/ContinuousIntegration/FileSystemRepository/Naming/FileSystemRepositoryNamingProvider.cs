using System;
using System.Collections.Generic;
using System.Linq;

using CMS.Base;
using CMS.DataEngine;
using CMS.Helpers;


namespace CMS.ContinuousIntegration.Internal
{
    /// <summary>
    /// Provides methods for registering custom functions to be used when object identifier or parent identifier is needed.
    /// Such identifier is used when deriving file or folder names for file system repository.
    /// </summary>
    public sealed class FileSystemRepositoryNamingProvider
    {
        #region "Fields"
        
        private static readonly FileSystemRepositoryNamingProvider instance = new FileSystemRepositoryNamingProvider();

        private readonly SafeDictionary<string, Func<ExtendedTranslationReference, string, string>> mGetObjectIdentifierMethods =
            new SafeDictionary<string, Func<ExtendedTranslationReference, string, string>>(StringComparer.InvariantCultureIgnoreCase);
        private readonly SafeDictionary<string, Func<string, ExtendedTranslationReference, string, string>> mGetParentIdentifierMethods =
            new SafeDictionary<string, Func<string, ExtendedTranslationReference, string, string>>(StringComparer.InvariantCultureIgnoreCase);

        #endregion


        #region "Static methods"

        /// <summary>
        /// Registers a function to be called when an object identifier for object of type <paramref name="objectType"/> is needed. Based on returned object identifier
        /// a file or folder name is derived.
        /// </summary>
        /// <param name="objectType">Object type for which the function provides object identifier.</param>
        /// <param name="getObjectIdentifier">Function deriving object identifier from translation reference and/or default object identifier.</param>
        /// <remarks>
        /// <para>
        /// When an object is being stored in the repository, a folder or file name is generated based on its object type and/or fields contained in translation reference.
        /// However, when the default object identifier is not suitable, it can be customized by registering a custom function.
        /// </para>
        /// <para>
        /// The <see cref="ExtendedTranslationReference.AdditionalFields"/> contains fields defined in <see cref="ContinuousIntegrationSettings.ObjectFileNameFields"/> of given <paramref name="objectType"/>.
        /// </para>
        /// </remarks>
        public static void RegisterGetObjectIdentifier(string objectType, Func<ExtendedTranslationReference, string, string> getObjectIdentifier)
        {
            instance.RegisterGetObjectIdentifierInternal(objectType, getObjectIdentifier);
        }


        /// <summary>
        /// Registers a function to be called when a parent object identifier for object of type <paramref name="objectType"/> is needed. Based on returned parent identifier
        /// a file or folder name is derived.
        /// </summary>
        /// <param name="objectType">Object type for which the function provides parent identifier.</param>
        /// <param name="getParentIdentifier">Function deriving parent identifier from child object type, translation reference and/or default parent identifier.</param>
        /// <remarks>
        /// <para>
        /// When an object is being stored in the repository, a parent folder or file name is generated based on its object type and/or fields contained in translation reference.
        /// However, when the default parent identifier is not suitable, it can be customized by registering a custom function.
        /// </para>
        /// <para>
        /// The <see cref="ExtendedTranslationReference.AdditionalFields"/> contains fields defined in <see cref="ContinuousIntegrationSettings.ObjectFileNameFields"/> of given <paramref name="objectType"/>.
        /// </para>
        /// </remarks>
        internal static void RegisterGetParentIdentifier(string objectType, Func<string, ExtendedTranslationReference, string, string> getParentIdentifier)
        {
            instance.RegisterGetParentIdentifierInternal(objectType, getParentIdentifier);
        }


        /// <summary>
        /// Gets object identifier based on type info, translation reference and/or default object identifier.
        /// </summary>
        /// <param name="translationReference">Translation reference of object for which the object identifier is requested.</param>
        /// <param name="defaultIdentifier">Default object identifier generated by the system.</param>
        /// <returns>Returns object identifier to be used when deriving file or folder name.</returns>
        public static string GetObjectIdentifier(ExtendedTranslationReference translationReference, string defaultIdentifier)
        {
            return instance.GetObjectIdentifierInternal(translationReference, defaultIdentifier);
        }


        /// <summary>
        /// Gets parent object identifier based on type info, translation reference and/or default parent identifier.
        /// </summary>
        /// <param name="childObjectType">Object type of child object that needs its parent identifier.</param>
        /// <param name="translationReference">Translation reference of object for which the parent identifier is requested.</param>
        /// <param name="defaultIdentifier">Default parent identifier generated by the system.</param>
        /// <returns>Returns parent identifier to be used when deriving parent file or folder name.</returns>
        internal static string GetParentIdentifier(string childObjectType, ExtendedTranslationReference translationReference, string defaultIdentifier)
        {
            return instance.GetParentIdentifierInternal(childObjectType, translationReference, defaultIdentifier);
        }


        /// <summary>
        /// Default system method providing object identifier when no specific function is registered.
        /// </summary>
        public string GetDefaultObjectIdentifier(ExtendedTranslationReference translationReference, string defaultIdentifier)
        {
            var typeInfo = translationReference.TypeInfo;
            var nameFromFields = GetObjectNameFromFields(translationReference);
            var usedName = nameFromFields ?? defaultIdentifier;

            if (typeInfo.IsCategory && String.Equals(usedName, "/", StringComparison.Ordinal))
            {
                return "root";
            }

            return nameFromFields;
        }


        /// <summary>
        /// Default system method providing parent identifier when no specific function is registered.
        /// </summary>
        internal static string GetDefaultParentIdentifier(string childObjectType, ExtendedTranslationReference translationReference, string defaultIdentifier)
        {
            var nameFromFields = GetObjectNameFromFields(translationReference);
            
            // Object type is included in the identifier if child object type can has more object types as its parent.
            bool includeObjectType = false;
            if (!String.IsNullOrEmpty(childObjectType))
            {
                // MetaFile is special case - it can be possibly child of any other object in the system and this relationship is not covered in type info.
                includeObjectType = childObjectType.Equals(MetaFileInfo.OBJECT_TYPE, StringComparison.OrdinalIgnoreCase);
                if (!includeObjectType)
                {
                    var childTypeInfo = ObjectTypeManager.GetTypeInfo(childObjectType, true);
                    includeObjectType = (childTypeInfo.RegisterAsChildToObjectTypes != null) && (childTypeInfo.RegisterAsChildToObjectTypes.Count > 1);
                }
            }            

            return TextHelper.MergeIfNotEmpty(
                "_",
                GetCustomOrDefaultParentIdentifier(translationReference.ObjectType, translationReference.ExtendedParent),
                includeObjectType ? translationReference.ObjectType : null,
                nameFromFields ?? (translationReference.CodeName ?? (translationReference.GUID == Guid.Empty ? null : translationReference.GUID.ToString()))
                );
        }

        #endregion


        #region "Methods"

        /// <summary>
        /// Registers object identifier resolution function for given object type.
        /// </summary>
        private void RegisterGetObjectIdentifierInternal(string objectType, Func<ExtendedTranslationReference, string, string> getObjectIdentifier)
        {
            if (objectType == null)
            {
                throw new ArgumentNullException("objectType", "Object type can not be null.");
            }
            if (getObjectIdentifier == null)
            {
                throw new ArgumentNullException("getObjectIdentifier", "Method providing object identifier can not be null.");
            }

            mGetObjectIdentifierMethods[objectType] = getObjectIdentifier;
        }


        /// <summary>
        /// Registers parent identifier resolution function for given object type.
        /// </summary>
        private void RegisterGetParentIdentifierInternal(string objectType, Func<string, ExtendedTranslationReference, string, string> getParentIdentifier)
        {
            if (objectType == null)
            {
                throw new ArgumentNullException("objectType", "Object type can not be null.");
            }
            if (getParentIdentifier == null)
            {
                throw new ArgumentNullException("getParentIdentifier", "Method providing parent identifier can not be null.");
            }

            mGetParentIdentifierMethods[objectType] = getParentIdentifier;
        }


        /// <summary>
        /// Gets an object identifier by invoking registered function. The function for resolving object identifier is determined as follows.
        /// If specific function is available for object type of type info, it is used.
        /// If specific function is available for original object type of type info, it is used.
        /// Otherwise the default function is used.
        /// </summary>
        private string GetObjectIdentifierInternal(ExtendedTranslationReference translationReference, string defaultIdentifier)
        {
            if (translationReference == null)
            {
                throw new ArgumentNullException("translationReference", "Translation reference can not be null.");
            }

            var typeInfo = translationReference.TypeInfo;
            if (mGetObjectIdentifierMethods.ContainsKey(typeInfo.ObjectType))
            {
                return mGetObjectIdentifierMethods[typeInfo.ObjectType].Invoke(translationReference, defaultIdentifier);
            }
            if ((typeInfo.OriginalTypeInfo != null) && mGetObjectIdentifierMethods.ContainsKey(typeInfo.OriginalObjectType))
            {
                return mGetObjectIdentifierMethods[typeInfo.OriginalObjectType].Invoke(translationReference, defaultIdentifier);
            }

            return GetDefaultObjectIdentifier(translationReference, defaultIdentifier);
        }


        /// <summary>
        /// Gets an parent identifier by invoking registered function. The function for resolving parent identifier is determined as follows.
        /// If specific function is available for object type of type info, it is used.
        /// If specific function is available for original object type of type info, it is used.
        /// Otherwise the default function is used.
        /// </summary>
        private string GetParentIdentifierInternal(string childObjectType, ExtendedTranslationReference translationReference, string defaultIdentifier)
        {
            if (translationReference == null)
            {
                throw new ArgumentNullException("translationReference", "Translation reference can not be null.");
            }

            var typeInfo = translationReference.TypeInfo;
            if (mGetParentIdentifierMethods.ContainsKey(typeInfo.ObjectType))
            {
                return mGetParentIdentifierMethods[typeInfo.ObjectType].Invoke(childObjectType, translationReference, defaultIdentifier);
            }
            if ((typeInfo.OriginalTypeInfo != null) && mGetParentIdentifierMethods.ContainsKey(typeInfo.OriginalObjectType))
            {
                return mGetParentIdentifierMethods[typeInfo.OriginalObjectType].Invoke(childObjectType, translationReference, defaultIdentifier);
            }

            return GetDefaultParentIdentifier(childObjectType, translationReference, defaultIdentifier);
        }


        /// <summary>
        /// Gets object's name. Name is retrieved from object's fields specified in <see cref="ContinuousIntegrationSettings.ObjectFileNameFields"/>.
        /// </summary>
        /// <param name="translationReference">Translation reference of object for which to get the name.</param>
        /// <returns>Given object's name.</returns>
        private static string GetObjectNameFromFields(ExtendedTranslationReference translationReference)
        {
            var typeInfo = translationReference.TypeInfo;
            var objectNameFieldsValues = new List<string>();
            foreach (var fieldName in typeInfo.ContinuousIntegrationSettings.ObjectFileNameFields)
            {
                string columnValue;
                if (typeInfo.IsForeignKey(fieldName))
                {
                    var foreignObjectType = typeInfo.ParentIDColumn == fieldName 
                        ? typeInfo.ParentObjectType 
                        : typeInfo.ObjectDependencies.First(x => x.DependencyColumn == fieldName).DependencyObjectType;

                    columnValue = GetCustomOrDefaultParentIdentifier(translationReference.ObjectType, translationReference.TranslationHelper.TranslationReferenceLoader.LoadExtendedFromDatabase(foreignObjectType, ValidationHelper.GetInteger(translationReference.AdditionalFields[fieldName], 0)));
                }
                else
                {
                    columnValue = ValidationHelper.GetString(translationReference.AdditionalFields[fieldName], String.Empty);
                }

                if (!String.IsNullOrWhiteSpace(columnValue))
                {
                    objectNameFieldsValues.Add(columnValue);
                }
            }

            return objectNameFieldsValues.Count > 0 ? String.Join("_", objectNameFieldsValues) : null;
        }


        private static string GetCustomOrDefaultParentIdentifier(string childObjectType, ExtendedTranslationReference translationReference)
        {
            if (translationReference == null)
            {
                return null;
            }

            return GetParentIdentifier(childObjectType, translationReference, translationReference.ToString()) ?? GetDefaultParentIdentifier(childObjectType, translationReference, translationReference.ToString());
        }

        #endregion


        #region "Constructors"

        /// <summary>
        /// Initializer enforcing singleton.
        /// </summary>
        private FileSystemRepositoryNamingProvider()
        {
            
        }

        #endregion
    }
}
